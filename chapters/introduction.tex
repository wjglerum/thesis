\chapter{Introduction}
\label{chap:introduction}
%\emph{You describe in detail what problem the research is addressing, and what is the motivation to address this problem. There is a concise and objective statement of the research questions, hypotheses and goals. It is made clear why these questions and goals are important and relevant to the world outside the university (assuming it exists). You can already split the main research question into subquestions in this chapter. This section also describes an analysis of the problem: where does it occur and how, how often, and what are the consequences? An important part is also to scope the research: what aspects are included and what aspects are deliberately left out, and why?} This chapter aims to explain the why of this thesis. First we explore and explain the problems with managing virtual container networks, next we elaborate on the motivation for this thesis. Last we introduce the research questions and explain why these are relevant.

\section{Problem statement}
\label{sec:problem-statement}
At the moment applications are moved from traditional deployments to container deployments. Instead of manually logging into a server, downloading, installing and configuring application we can now download and run a container image with a single command. A container is a set of isolated processes and application dependencies that are packaged together in an image. This container image can run locally on a developer's machine or on a container orchestration platform in production. Containers are considered more flexible than \glspl{vm} as you do not need to run and boot an entire \gls{os}. The most well known system for running containers locally is Docker\cite{docker}. To make applications highly available in production people make use of a container orchestration platform like Kubernetes\cite{kubernetes} or \gls{dcos}\cite{dcos} to allow scaling of those containers. Cloud providers such as \gls{aws}\cite{aws} and \gls{gcp}\cite{gcp} even enable you to run containers without worrying about the underlying infrastructure.

In production workloads operators want to isolate applications. The traditional way is to use firewall policies and different physical networks between applications in a datacenter. Container operators need to be more flexible as workloads change all the time. That is what let to the introduction of \gls{sdn} to create virtual networks within a container orchestration platform. There are different implementations and vendors providing virtual networks and policies, such as Project Calico\cite{calico} and Cilium\cite{cilium}. These plugins are standardised with the \gls{cni}\cite{cni} standard, a set of specifications and plugins for configuring virtual networks. \Gls{cni} allows you to chain different plugins together, for example for \gls{ipam}, virtual networks and network policies by Calico.

The focus of this thesis will be on \gls{dcos} and Calico as one of Lunatech's clients uses those technologies for their container orchestration to build an \gls{iot} platform for cars. Collecting data from cars forces us to take privacy seriously and we have to make sure that the data is only accessible by the right services. Moreover the client wants to isolate workloads from different tenants within their organisation and logically split workloads in the data processing pipeline. Currently it is difficult for an operator of a cluster to see and manage the virtual networks and policies in \gls{dcos} as each \gls{cni} plugin uses its own control plane. An operator must reach down the host machines to inspect the network configuration. To allow easy administration there is a need for a solution to at least get an overview of the networks and be able to inspect those. As at the moment there is no easy way for the client to check if workloads are really isolated. 

\section{Motivation}
\label{motiviation}
When there is visibility on the implemented networks and policies we can empower administrators with better means to manage the virtual networks on a container orchestration platform, enabling a developer to simply allow or deny traffic between different applications or namespaces. This can be achieved by erasing the differences between the \gls{cni} plugins and hiding their complexity from them. As an extension we could also automatically provision new \gls{cni} plugins to help operators create new network services in a flexible manner, without worrying about the concrete implementation details. Furthermore when an operator is aware of the networks present he can use existing tools to get more insights in the network traffic for measuring network flows. And we could also provide basic networking monitoring solutions to the operator.

On a container orchestration platform we also need an ingress point to allow traffic to the container workloads. This involves for example configuring load balancers on your cloud platform. However when something changes on the container orchestration level, an operator must also update the relevant load balancers to redirect the traffic to the correct containers. In and out going traffic to your cluster is called North-South traffic. East-West traffic on the other hand is within the cluster when for example a pool of web servers talk to a pool of application servers. The application servers could be on a different virtual network protected by network policies and need to be load balanced to be highly available for the web servers.

Furthermore when this is in place we can also look at automating the tasks of an administrator as much as possible. Here we could think of self-adapting networks, where the system detects a sub-optimal solution and applies the new configuration in place, with or without the confirmation of the operator. It is often the case that a firewall rule is blocking traffic. Which can be hard to debug for an application developer who wants to deploy his application to find the exact problem, as his application works fine on his local machine. A visualisation can be created to help an operator to gain insight of the applied network policies, allowing to find the problematic policy faster in an interactive process. Self adapting networks and visualisations are outside the scope of this thesis, as we first need a way of exposing the current network infrastructure. When everything is in place it becomes easier to think of new use cases and ways to help operators and developers to debug the cluster and the applied policies.

\section{Research questions}
\label{sec:research-questions}
The following research questions were raised with the help of the motivation above during the formulation of this thesis:
\begin{itemize}
    \item \textbf{RQ1} What are the current problems in managing virtual container networks and how do different vendors address this issue?
    \item \textbf{RQ2} How can the management of virtual container networks and network policies be improved?   
\end{itemize}

\subsection{RQ1}
\label{subsec:rq1}
First we need to know what the problems are in the current solutions with managing virtual networks, before we can propose a solution. This can be based on the direct experience of people within the client's project and/or information found online or in previous research. Furthermore we could look at what other providers are doing to address this issue. At the moment Kubernetes is very popular and adapted by a lot of companies and developers. We could for example learn from their experience and mistakes.

\subsection{RQ2}
\label{subsec:rq2}
This question aims to find a solution for the concrete problems found with the first question. To prevent reinventing the wheel we should critically assess if we can reuse some of the solutions from other providers or standards. And see if we can improve the current situation by suggesting a new solution in the form of a \gls{poc}.

\section{Organisation}
\label{sec:organisation}
This thesis is organised as follows: Chapter~\ref{chap:background} gives an overview of the relevant technologies, next Chapter~\ref{chap:research} lists the results for the research of \textbf{RQ1}. In Chapter~\ref{chap:proof-of-concept} we explain how the \gls{poc} built for this thesis works and in Chapter~\ref{chap:validation} we see how this answers \textbf{RQ2}. To finish we discuss the results and future work in Chapter~\ref{chap:conclusions} and \ref{chap:future-work}.
